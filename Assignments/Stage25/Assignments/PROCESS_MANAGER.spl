alias functionNum R1;
alias PID R2;
alias counter R5;

if(functionNum == GET_PCB_ENTRY) then
    alias retVal R0;
    retVal = -1;
    counter = 0;
    while(counter < MAX_PROC_NUM) do
       if([PROCESS_TABLE + counter*16 + 4] == TERMINATED) then
            [PROCESS_TABLE + counter*16 + 1] = counter;
            retVal = counter;
            [PROCESS_TABLE + counter*16 + 4] = ALLOCATED;
            [PROCESS_TABLE + counter*16 + 14] = PAGE_TABLE_BASE + counter*20;
            [PROCESS_TABLE + counter*16 + 15] = 10;
            return;
       endif;
       counter = counter + 1;
    endwhile;
    return;
endif;

if(functionNum == FREE_USER_AREA_PAGE) then
    alias userAreaPage R6;
    userAreaPage = [PROCESS_TABLE + PID*16 + 11];

    // Release all valid semaphores and files
    counter = 0;
    while (counter < 8) do
        if([userAreaPage*512 + RESOURCE_TABLE_OFFSET + counter*2] == SEMAPHORE) then
            [userAreaPage*512 + RESOURCE_TABLE_OFFSET + counter*2] = -1;

            // Release the semaphore
            multipush(R1, R2, R5, R6);
            R1 = RELEASE_SEMAPHORE;
            R2 = PID;
            R3 = [userAreaPage*512 + RESOURCE_TABLE_OFFSET + counter*2 + 1];
            call RESOURCE_MANAGER;
            multipop(R1, R2, R5, R6);
        endif;

        if([userAreaPage*512 + RESOURCE_TABLE_OFFSET + counter*2] == FILE) then
            [userAreaPage*512 + RESOURCE_TABLE_OFFSET + counter*2] = -1;

            // Release the file
            multipush(R1, R2, R5, R6);
            R1 = CLOSE;
            R2 = [userAreaPage*512 + RESOURCE_TABLE_OFFSET + counter*2 + 1];
            call FILE_MANAGER;
            multipop(R1, R2, R5, R6);
        endif;

        counter = counter + 1;
    endwhile;

    R1 = RELEASE_PAGE;
    R2 = userAreaPage;
    call MEMORY_MANAGER;

    return;
endif;

if(functionNum == EXIT_PROCESS) then
    //Calling Free User Area Page
    multipush(R1, R2);
    R1 = FREE_USER_AREA_PAGE;
    call PROCESS_MANAGER;
    multipop(R1, R2);

    //Calling Free Page Table
    multipush(R1, R2);
    R1 = FREE_PAGE_TABLE;
    call PROCESS_MANAGER;
    multipop(R1, R2);

    // If now Exec
    if([PROCESS_TABLE + PID*16 + 9] != 9) then
        counter = 1;
        while(counter < 16) do
            // Make waiting processes ready
            if(([PROCESS_TABLE + counter*16 + 4] == WAIT_PROCESS) && ([PROCESS_TABLE + counter*16 + 5] == PID)) then
                [PROCESS_TABLE + counter*16 + 4] = READY;
            endif;
            // Invalidate if PID = PPID
            if([PROCESS_TABLE + counter*16 + 2] == PID) then
                [PROCESS_TABLE + counter*16 + 2] = -1;
            endif;
            counter = counter + 1;
        endwhile;
    endif;

    [PROCESS_TABLE + PID*16 + 4] = TERMINATED;
    return;
endif;

if(functionNum == FREE_PAGE_TABLE) then
    alias PTBRCopy  R10;
    PTBRCopy = PAGE_TABLE_BASE + PID*20;

    //Free library
    [PTBRCopy + 0] = -1;
    [PTBRCopy + 1] = "0000";
    [PTBRCopy + 2] = -1;
    [PTBRCopy + 3] = "0000";

    counter = 2;
    while(counter < 10) do
        if([PTBRCopy + 2*counter] != -1) then
            //Free the page
            multipush(R1, R2, R5, R10);
            R1 = RELEASE_PAGE;
            R2 = [PTBRCopy + 2*counter];
            call MEMORY_MANAGER;
            multipop(R1, R2, R5, R10);

            //Invalidate the entries
            [PTBRCopy + 2*counter] = -1;
            [PTBRCopy + 2*counter + 1] = "0000";
        endif;
        counter = counter + 1;
    endwhile;

    //Release Block for valid DISK_MAP_TABLE entries
    counter = 2;
    while(counter <= 9) do
        //Release the disk block
        if([DISK_MAP_TABLE + PID*10 + counter] != -1) then
            multipush(R1, R2, R5);
            R1 = RELEASE_BLOCK;
            R2 = [DISK_MAP_TABLE + PID*10 + counter];
            call MEMORY_MANAGER;
            multipop(R1, R2, R5);
        endif;

        //Overly complicated while loop :)
        if(counter == 3) then
            counter = 8;
            continue;
        endif;
        counter = counter + 1;
    endwhile;

    //Invalidate DISK_MAP_TABLE entries;
    counter = 0;
    while(counter < 10) do
        [DISK_MAP_TABLE + PID*10 + counter] = -1;
        counter = counter + 1;
    endwhile;
    return;
endif;

if(functionNum == KILL_ALL) then
    // Acquire all valid Inodes
    counter = 0;
    while(counter < MAX_FILE_NUM) do
        if([INODE_TABLE + counter*16 + 1] != -1) then
            multipush(R1, R2, R5);
            R1 = ACQUIRE_INODE;
            R2 = PID;
            R3 = counter;
            call RESOURCE_MANAGER;
            multipop(R1, R2, R5);
        endif;
        counter = counter + 1;
    endwhile;

    counter = 2;
    while(counter < MAX_PROC_NUM) do
        if((counter == SWAPPER_DAEMON) || (counter == PID)) then
            counter = counter + 1;
            continue;
        endif;
        // Terminate all running processes
        if([PROCESS_TABLE + counter*16 + 4] != TERMINATED) then
            multipush(R1, R2, R5);
            R1 = EXIT_PROCESS;
            R2 = [SYSTEM_STATUS_TABLE + 1];
            call PROCESS_MANAGER;
            multipop(R1, R2, R5);
        endif;

        counter = counter + 1;
    endwhile;

    // Release all valid Inodes
    counter = 0;
    while(counter < MAX_FILE_NUM) do
        if([INODE_TABLE + counter*16 + 1] != -1) then
            multipush(R1, R2, R5);
            R1 = RELEASE_INODE;
            R2 = PID;
            R3 = counter;
            call RESOURCE_MANAGER;
            multipop(R1, R2, R5);
        endif;
        counter = counter + 1;
    endwhile;

    return;
endif;
